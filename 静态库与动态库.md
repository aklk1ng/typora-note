# 库的工作原理

## 1.静态库

### 加载原理

- 在程序编译的最后一个阶段（链接），提供的静态库也会被打包到可执行程序中，
- 因此不会出现静态库找不到的情况

## 2.动态库

### 加载原理

- 在程序编译的最后一个阶段（链接）

- 在 gcc 命令中虽然指定了库路径，但这个路径并没有记录到可执行程序中，只是检查了库文件是否存在

- 同样对应的动态库文件也没有被打包到可执行程序中，在可执行程序中只是记住了库的名字

- 当执行程序时，先检测动态库是否可以被加载，只有当动态库中的函数被调用时，这个动态库才会加载到内存

  #### 动态链接器

  ##### 搜索路径

  1. 可执行文件内部的 DT_RPATH 段
  2. 系统的环境变量`<LD_LIBRARY_PATH>`
  3. 系统动态库的缓存文件`</etc/ld.so.cache>`
  4. 存储动态库/静态库的系统目录`</lib/></usr/lib>`等

## 解决方案

##### 将库路径添加到环境变量 LD_LIBRARY_PATH 中

1. 找到相关的配置文件

   - 用户级别：`<~/.bashrc>`对当前用户有效
   - 系统级别：`</etc/profile>`对所有用户有效

2. 在文件的末尾添加

   ```shell
   export LIBRARY_PATH=$LIBRARY:动态库绝对路径
   ```

3. 让修改的配置生效

   - 修改了用户级别的文件，重启终端

   - 修改了系统级别的文件，注销或关闭系统，再开机

   - 使用命令

   - ```shell
       . ~/.bashrc或者source ~/.bashrc
     ```

   ##### 更新 `</etc/ld.so.conf>`

   - 在文件末尾添加动态库绝对路径
   - 执行 sudo ldconfig 进行更新文件

   - 拷贝动态库文件到系统目录`</lib/>`或者`</usr/lib>`中（或者将库的软连接文件放进去）

   ## 优缺点

   ### 1.静态库

   #### 优点：

   - 静态库被打包到程序中加载速度快
   - 发布程序无需提供静态库。移植方便

   #### 缺点：

   - 相同的库文件数据可能在内存中被加载多份，浪费系统资源，浪费内存
   - 库文件更新需要重新编译源文件，生成可执行文件，浪费时间

   ### 2.动态库

   #### 优点：

   - 可以实现不同进程间的资源共享
   - 动态库升级简单，只需要替换库文件，无需重新编译应用文件
   - 程序员可以控制何时加载动态库

   #### 缺点：

   - 加载速度比静态库慢
   - 发布程序需要提供依赖的动态库
